
CREATE OR REPLACE PACKAGE lab_hr_pkg AS

  -- Procedury zadań z cw06
  PROCEDURE add_job (
    p_job_id    IN jobs.job_id%TYPE,
    p_job_title IN jobs.job_title%TYPE
  );

  PROCEDURE update_job_title (
    p_job_id     IN jobs.job_id%TYPE,
    p_new_title  IN jobs.job_title%TYPE
  );

  PROCEDURE delete_job (
    p_job_id IN jobs.job_id%TYPE
  );

  PROCEDURE get_emp_salary_name (
    p_emp_id   IN  employees.employee_id%TYPE,
    p_lastname OUT employees.last_name%TYPE,
    p_salary   OUT employees.salary%TYPE
  );

  PROCEDURE add_employee (
    p_last_name  IN employees.last_name%TYPE,
    p_first_name IN employees.first_name%TYPE,
    p_salary     IN employees.salary%TYPE,
    p_job_id     IN employees.job_id%TYPE      DEFAULT 1,
    p_dept_id    IN employees.department_id%TYPE DEFAULT 10
  );

  PROCEDURE avg_salary_under_manager (
    p_manager_id IN  employees.manager_id%TYPE,
    p_avg_sal    OUT NUMBER
  );

  PROCEDURE raise_dept_salary (
    p_dept_id IN employees.department_id%TYPE,
    p_percent IN NUMBER
  );

  PROCEDURE move_employee (
    p_emp_id      IN employees.employee_id%TYPE,
    p_new_dept_id IN employees.department_id%TYPE
  );

  PROCEDURE delete_department (
    p_dept_id IN departments.department_id%TYPE
  );

  -- Funkcje z cw07 (wybrane)
  FUNCTION full_name (
    p_emp_id IN employees.employee_id%TYPE
  ) RETURN VARCHAR2;

  FUNCTION employee_commission (
    p_emp_id IN employees.employee_id%TYPE
  ) RETURN NUMBER;

  FUNCTION work_age (
    p_emp_id IN employees.employee_id%TYPE
  ) RETURN NUMBER;

END lab_hr_pkg;
/
------------------------------------------------------------
CREATE OR REPLACE PACKAGE BODY lab_hr_pkg AS

  PROCEDURE add_job (
    p_job_id    IN jobs.job_id%TYPE,
    p_job_title IN jobs.job_title%TYPE
  ) AS
  BEGIN
    INSERT INTO jobs (job_id, job_title, min_salary, max_salary)
    VALUES (p_job_id, p_job_title, 0, 0);
    DBMS_OUTPUT.PUT_LINE('Dodano JOB_ID = ' || p_job_id);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd add_job: ' || SQLERRM);
  END add_job;


  PROCEDURE update_job_title (
    p_job_id     IN jobs.job_id%TYPE,
    p_new_title  IN jobs.job_title%TYPE
  ) AS
  BEGIN
    UPDATE jobs
    SET    job_title = p_new_title
    WHERE  job_id = p_job_id;

    IF SQL%ROWCOUNT = 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Nie zaktualizowano żadnego JOB (brak ID)');
    END IF;
    DBMS_OUTPUT.PUT_LINE('Zaktualizowano JOB_ID = ' || p_job_id);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd update_job_title: ' || SQLERRM);
  END update_job_title;


  PROCEDURE delete_job (
    p_job_id IN jobs.job_id%TYPE
  ) AS
  BEGIN
    DELETE FROM jobs WHERE job_id = p_job_id;
    IF SQL%ROWCOUNT = 0 THEN
      RAISE_APPLICATION_ERROR(-20002, 'Nie usunięto żadnego JOB (brak ID)');
    END IF;
    DBMS_OUTPUT.PUT_LINE('Usunięto JOB_ID = ' || p_job_id);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd delete_job: ' || SQLERRM);
  END delete_job;


  PROCEDURE get_emp_salary_name (
    p_emp_id   IN  employees.employee_id%TYPE,
    p_lastname OUT employees.last_name%TYPE,
    p_salary   OUT employees.salary%TYPE
  ) AS
  BEGIN
    SELECT last_name, salary
    INTO   p_lastname, p_salary
    FROM   employees
    WHERE  employee_id = p_emp_id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE('Pracownik nie istnieje');
      p_lastname := NULL;
      p_salary   := NULL;
  END get_emp_salary_name;


  PROCEDURE add_employee (
    p_last_name  IN employees.last_name%TYPE,
    p_first_name IN employees.first_name%TYPE,
    p_salary     IN employees.salary%TYPE,
    p_job_id     IN employees.job_id%TYPE,
    p_dept_id    IN employees.department_id%TYPE
  ) AS
  BEGIN
    IF p_salary > 20000 THEN
      RAISE_APPLICATION_ERROR(-20003, 'Wynagrodzenie > 20000!');
    END IF;

    INSERT INTO employees (
      employee_id, last_name, first_name, salary,
      job_id, department_id, hire_date, email
    ) VALUES (
      emp_seq.NEXTVAL, p_last_name, p_first_name, p_salary,
      p_job_id, p_dept_id, SYSDATE,
      LOWER(p_first_name || '.' || p_last_name || '@example.com')
    );

    DBMS_OUTPUT.PUT_LINE('Dodano pracownika: ' || p_first_name || ' ' || p_last_name);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd add_employee: ' || SQLERRM);
  END add_employee;


  PROCEDURE avg_salary_under_manager (
    p_manager_id IN  employees.manager_id%TYPE,
    p_avg_sal    OUT NUMBER
  ) AS
  BEGIN
    SELECT AVG(salary)
    INTO   p_avg_sal
    FROM   employees
    WHERE  manager_id = p_manager_id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      p_avg_sal := NULL;
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd avg_salary_under_manager: ' || SQLERRM);
      p_avg_sal := NULL;
  END avg_salary_under_manager;


  PROCEDURE raise_dept_salary (
    p_dept_id IN employees.department_id%TYPE,
    p_percent IN NUMBER
  ) AS
  BEGIN
    UPDATE employees e
    SET    e.salary = e.salary * (1 + p_percent/100)
    WHERE  e.department_id = p_dept_id
    AND EXISTS (
          SELECT 1 FROM jobs j
          WHERE j.job_id = e.job_id
            AND e.salary * (1 + p_percent/100)
                BETWEEN j.min_salary AND j.max_salary
        );

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano: ' || SQL%ROWCOUNT || ' pracowników.');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -2291 THEN
        DBMS_OUTPUT.PUT_LINE('Błąd FK: nie istnieje department_id');
      ELSE
        DBMS_OUTPUT.PUT_LINE('Błąd raise_dept_salary: ' || SQLERRM);
      END IF;
  END raise_dept_salary;


  PROCEDURE move_employee (
    p_emp_id      IN employees.employee_id%TYPE,
    p_new_dept_id IN employees.department_id%TYPE
  ) AS
    v_cnt NUMBER;
    v_emp NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_emp FROM employees WHERE employee_id = p_emp_id;
    IF v_emp = 0 THEN
      RAISE_APPLICATION_ERROR(-20004, 'Pracownik nie istnieje!');
    END IF;

    SELECT COUNT(*) INTO v_cnt FROM departments WHERE department_id = p_new_dept_id;
    IF v_cnt = 0 THEN
      RAISE_APPLICATION_ERROR(-20005, 'Docelowy departament nie istnieje!');
    END IF;

    UPDATE employees
    SET    department_id = p_new_dept_id
    WHERE  employee_id = p_emp_id;

    DBMS_OUTPUT.PUT_LINE('Przeniesiono pracownika ' || p_emp_id ||
                         ' do departamentu ' || p_new_dept_id);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd move_employee: ' || SQLERRM);
  END move_employee;


  PROCEDURE delete_department (
    p_dept_id IN departments.department_id%TYPE
  ) AS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM   employees
    WHERE  department_id = p_dept_id;

    IF v_cnt > 0 THEN
      RAISE_APPLICATION_ERROR(-20006, 'Nie można usunąć departamentu – są pracownicy!');
    END IF;

    DELETE FROM departments WHERE department_id = p_dept_id;
    DBMS_OUTPUT.PUT_LINE('Usunięto departament ' || p_dept_id);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd delete_department: ' || SQLERRM);
  END delete_department;


  FUNCTION full_name (
    p_emp_id IN employees.employee_id%TYPE
  ) RETURN VARCHAR2 AS
    v_first employees.first_name%TYPE;
    v_last  employees.last_name%TYPE;
  BEGIN
    SELECT first_name, last_name
    INTO   v_first, v_last
    FROM   employees
    WHERE  employee_id = p_emp_id;

    RETURN v_last || ', ' || v_first;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN 'BRAK PRACOWNIKA';
  END full_name;


  FUNCTION employee_commission (
    p_emp_id IN employees.employee_id%TYPE
  ) RETURN NUMBER AS
    v_sal  employees.salary%TYPE;
    v_comm employees.commission_pct%TYPE;
  BEGIN
    SELECT salary, commission_pct
    INTO   v_sal, v_comm
    FROM   employees
    WHERE  employee_id = p_emp_id;

    RETURN v_sal * NVL(v_comm, 0);
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN 0;
  END employee_commission;


  FUNCTION work_age (
    p_emp_id IN employees.employee_id%TYPE
  ) RETURN NUMBER AS
    v_age NUMBER;
  BEGIN
    SELECT FLOOR(MONTHS_BETWEEN(SYSDATE, hire_date) / 12)
    INTO   v_age
    FROM   employees
    WHERE  employee_id = p_emp_id;

    RETURN v_age;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN NULL;
  END work_age;

END lab_hr_pkg;
/

EXEC lab_hr_pkg.add_job(9100, 'PKG_JOB');
SELECT lab_hr_pkg.full_name(100) FROM dual;



--------------------------------------------------------------------
-- 2) PAKIET REGIONS – CRUD + WYJĄTKI + AUDYT
--------------------------------------------------------------------

-- Tabela audytu (log błędów) – uruchom raz
CREATE TABLE regions_audit (
  audit_id     NUMBER GENERATED ALWAYS AS IDENTITY,
  operation    VARCHAR2(30),
  region_id    NUMBER,
  error_code   NUMBER,
  error_msg    VARCHAR2(4000),
  audit_date   DATE
);

------------------------------------------------------------
CREATE OR REPLACE PACKAGE regions_pkg AS

  -- własne wyjątki (kody)
  e_region_name_exists  EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_region_name_exists, -20050);

  e_region_has_countries EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_region_has_countries, -20051);

  -- CRUD
  PROCEDURE add_region (
    p_region_id   IN regions.region_id%TYPE,
    p_region_name IN regions.region_name%TYPE
  );

  PROCEDURE update_region_name (
    p_region_id   IN regions.region_id%TYPE,
    p_new_name    IN regions.region_name%TYPE
  );

  PROCEDURE delete_region (
    p_region_id IN regions.region_id%TYPE
  );

  PROCEDURE get_region (
    p_region_id   IN  regions.region_id%TYPE,
    p_region_name OUT regions.region_name%TYPE
  );

  PROCEDURE get_regions_by_name (
    p_pattern IN VARCHAR2,
    p_cur     OUT SYS_REFCURSOR
  );

  -- procedura logująca błędy do tabeli audytowej
  PROCEDURE log_error (
    p_operation  IN VARCHAR2,
    p_region_id  IN NUMBER,
    p_errcode    IN NUMBER,
    p_errmsg     IN VARCHAR2
  );

END regions_pkg;
/
------------------------------------------------------------
CREATE OR REPLACE PACKAGE BODY regions_pkg AS

  PROCEDURE log_error (
    p_operation  IN VARCHAR2,
    p_region_id  IN NUMBER,
    p_errcode    IN NUMBER,
    p_errmsg     IN VARCHAR2
  ) IS
  BEGIN
    INSERT INTO regions_audit(operation, region_id, error_code, error_msg, audit_date)
    VALUES (p_operation, p_region_id, p_errcode, SUBSTR(p_errmsg,1,4000), SYSDATE);
  END log_error;


  PROCEDURE add_region (
    p_region_id   IN regions.region_id%TYPE,
    p_region_name IN regions.region_name%TYPE
  ) AS
    v_cnt NUMBER;
  BEGIN
    -- sprawdź, czy istnieje region o tej samej nazwie
    SELECT COUNT(*)
    INTO   v_cnt
    FROM   regions
    WHERE  UPPER(region_name) = UPPER(p_region_name);

    IF v_cnt > 0 THEN
      RAISE e_region_name_exists;
    END IF;

    INSERT INTO regions(region_id, region_name)
    VALUES (p_region_id, p_region_name);

    DBMS_OUTPUT.PUT_LINE('Dodano region: ' || p_region_name);

  EXCEPTION
    WHEN e_region_name_exists THEN
      DBMS_OUTPUT.PUT_LINE('Błąd: region o nazwie ' || p_region_name || ' już istnieje.');
      log_error('ADD_REGION', p_region_id, SQLCODE, SQLERRM);
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Inny błąd add_region: ' || SQLERRM);
      log_error('ADD_REGION', p_region_id, SQLCODE, SQLERRM);
  END add_region;


  PROCEDURE update_region_name (
    p_region_id   IN regions.region_id%TYPE,
    p_new_name    IN regions.region_name%TYPE
  ) AS
  BEGIN
    UPDATE regions
    SET    region_name = p_new_name
    WHERE  region_id   = p_region_id;

    IF SQL%ROWCOUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('Brak regionu o ID = ' || p_region_id);
    ELSE
      DBMS_OUTPUT.PUT_LINE('Zmieniono nazwę regionu ' || p_region_id ||
                           ' na ' || p_new_name);
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd update_region_name: ' || SQLERRM);
      log_error('UPDATE_REGION', p_region_id, SQLCODE, SQLERRM);
  END update_region_name;


  PROCEDURE delete_region (
    p_region_id IN regions.region_id%TYPE
  ) AS
    v_cnt NUMBER;
  BEGIN
    -- sprawdź, czy są przypisane kraje
    SELECT COUNT(*)
    INTO   v_cnt
    FROM   countries
    WHERE  region_id = p_region_id;

    IF v_cnt > 0 THEN
      RAISE e_region_has_countries;
    END IF;

    DELETE FROM regions
    WHERE  region_id = p_region_id;

    IF SQL%ROWCOUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('Brak regionu o ID = ' || p_region_id);
    ELSE
      DBMS_OUTPUT.PUT_LINE('Usunięto region ID = ' || p_region_id);
    END IF;

  EXCEPTION
    WHEN e_region_has_countries THEN
      DBMS_OUTPUT.PUT_LINE('Nie można usunąć regionu: są przypisane kraje.');
      log_error('DELETE_REGION', p_region_id, SQLCODE, SQLERRM);
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd delete_region: ' || SQLERRM);
      log_error('DELETE_REGION', p_region_id, SQLCODE, SQLERRM);
  END delete_region;


  PROCEDURE get_region (
    p_region_id   IN  regions.region_id%TYPE,
    p_region_name OUT regions.region_name%TYPE
  ) AS
  BEGIN
    SELECT region_name
    INTO   p_region_name
    FROM   regions
    WHERE  region_id = p_region_id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      p_region_name := NULL;
  END get_region;


  PROCEDURE get_regions_by_name (
    p_pattern IN VARCHAR2,
    p_cur     OUT SYS_REFCURSOR
  ) AS
  BEGIN
    OPEN p_cur FOR
      SELECT region_id, region_name
      FROM   regions
      WHERE  UPPER(region_name) LIKE UPPER('%' || p_pattern || '%');
  END get_regions_by_name;

END regions_pkg;
/
EXEC regions_pkg.add_region(10, 'TestRegion');
EXEC regions_pkg.delete_region(1);



--------------------------------------------------------------------
-- 3) PAKIET DO OBLICZEŃ STATYSTYCZNYCH DLA DEPARTAMENTÓW
--------------------------------------------------------------------
CREATE OR REPLACE PACKAGE dept_stats_pkg AS

  FUNCTION avg_dept_salary (
    p_dept_id IN employees.department_id%TYPE
  ) RETURN NUMBER;

  PROCEDURE job_min_max_salary (
    p_job_id IN jobs.job_id%TYPE,
    p_min    OUT NUMBER,
    p_max    OUT NUMBER
  );

  PROCEDURE generate_dept_report (
    p_dept_id IN employees.department_id%TYPE
  );

END dept_stats_pkg;
/
------------------------------------------------------------
CREATE OR REPLACE PACKAGE BODY dept_stats_pkg AS

  FUNCTION avg_dept_salary (
    p_dept_id IN employees.department_id%TYPE
  ) RETURN NUMBER AS
    v_avg NUMBER;
  BEGIN
    SELECT AVG(salary)
    INTO   v_avg
    FROM   employees
    WHERE  department_id = p_dept_id;

    RETURN v_avg;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN NULL;
  END avg_dept_salary;


  PROCEDURE job_min_max_salary (
    p_job_id IN jobs.job_id%TYPE,
    p_min    OUT NUMBER,
    p_max    OUT NUMBER
  ) AS
  BEGIN
    SELECT MIN(salary), MAX(salary)
    INTO   p_min, p_max
    FROM   employees
    WHERE  job_id = p_job_id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      p_min := NULL;
      p_max := NULL;
  END job_min_max_salary;


  PROCEDURE generate_dept_report (
    p_dept_id IN employees.department_id%TYPE
  ) AS
    v_name departments.department_name%TYPE;
    v_avg  NUMBER;
    v_min  NUMBER;
    v_max  NUMBER;
  BEGIN
    SELECT department_name
    INTO   v_name
    FROM   departments
    WHERE  department_id = p_dept_id;

    SELECT AVG(salary), MIN(salary), MAX(salary)
    INTO   v_avg, v_min, v_max
    FROM   employees
    WHERE  department_id = p_dept_id;

    DBMS_OUTPUT.PUT_LINE('=== RAPORT DEPARTAMENTU ===');
    DBMS_OUTPUT.PUT_LINE('ID: ' || p_dept_id || ' | Nazwa: ' || v_name);
    DBMS_OUTPUT.PUT_LINE('Średnia pensja: ' || v_avg);
    DBMS_OUTPUT.PUT_LINE('Min pensja:     ' || v_min);
    DBMS_OUTPUT.PUT_LINE('Max pensja:     ' || v_max);

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE('Brak danych dla dep_id=' || p_dept_id);
  END generate_dept_report;

END dept_stats_pkg;
/
EXEC dept_stats_pkg.generate_dept_report(50);



--------------------------------------------------------------------
-- 4) PAKIET DO AUTOMATYCZNEJ WALIDACJI I AKTUALIZACJI DANYCH
--------------------------------------------------------------------
CREATE OR REPLACE PACKAGE data_cleanup_pkg AS

  PROCEDURE normalize_phone_numbers;

  PROCEDURE mass_raise_for_job (
    p_job_id  IN jobs.job_id%TYPE,
    p_percent IN NUMBER
  );

END data_cleanup_pkg;
/
------------------------------------------------------------
CREATE OR REPLACE PACKAGE BODY data_cleanup_pkg AS

  PROCEDURE normalize_phone_numbers IS
  BEGIN
    UPDATE employees
    SET phone_number =
      CASE
        WHEN REGEXP_LIKE(REPLACE(REPLACE(REPLACE(phone_number,'-',''),' ',''),'(',''), '^[0-9]{9}$')
        THEN '+48' || REPLACE(REPLACE(REPLACE(phone_number,'-',''),' ',''),'(','')
        ELSE phone_number
      END;
    DBMS_OUTPUT.PUT_LINE('Znormalizowano numery telefonów (tam gdzie możliwe).');
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd normalize_phone_numbers: ' || SQLERRM);
  END normalize_phone_numbers;


  PROCEDURE mass_raise_for_job (
    p_job_id  IN jobs.job_id%TYPE,
    p_percent IN NUMBER
  ) AS
  BEGIN
    UPDATE employees
    SET    salary = salary * (1 + p_percent/100)
    WHERE  job_id = p_job_id;

    DBMS_OUTPUT.PUT_LINE('Zaktualizowano ' || SQL%ROWCOUNT ||
                         ' pracowników na stanowisku ' || p_job_id);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Błąd mass_raise_for_job: ' || SQLERRM);
  END mass_raise_for_job;

END data_cleanup_pkg;
/

EXEC data_cleanup_pkg.normalize_phone_numbers;
EXEC data_cleanup_pkg.mass_raise_for_job('IT_PROG', 5);
